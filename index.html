<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AimStudio—Gridshot/Spidershot/Tracking</title>
  <style>
    :root{
      --accent:#29d391; --accent2:#45b7ff; --bg:#0b0f15; --panel:#0f151d; --line:#1a2430; --muted:#9db0c2;
      --txt:#e9eef3; --danger:#ff6b6b; --good:#38efb0; --fill:#2dd4bf; --track:#1d2836; --thumb:#e9eef3;
    }
    html,body{height:100%; margin:0; background:radial-gradient(1200px 600px at 50% 0%, #0f1722 0%, #0c0f14 40%, #0a0d12 100%); color:var(--txt); font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #game{position:fixed; inset:0; display:block}

    /* Global custom scrollbars (WebKit + Firefox) */
    *{scrollbar-color:#223243 #0c1218; scrollbar-width:thin}
    *::-webkit-scrollbar{width:10px; height:10px}
    *::-webkit-scrollbar-thumb{background:linear-gradient(180deg,#223243,#1a2430); border-radius:10px; border:2px solid #0f151d}
    *::-webkit-scrollbar-track{background:#0c1218; border-left:1px solid #15202b}

    /* mobile block */
    .mobile-block{position:fixed; inset:0; background:#0b0f15; color:#e9eef3; display:none; z-index:9999; align-items:center; justify-content:center; text-align:center; padding:24px}
    .mobile-block .box{background:#0f151d; border:1px solid #1b2632; border-radius:16px; padding:22px 26px; box-shadow:0 18px 40px rgba(0,0,0,.45)}
    .mobile-block h2{margin:0 0 6px; font-size:20px}
    .mobile-block p{margin:0; color:#9db0c2}

    /* ---------- Buttons ---------- */
    .btn{appearance:none; border:none; cursor:pointer; padding:10px 14px; border-radius:14px; font-weight:800; letter-spacing:.4px}
    .btn.primary{
      border-radius:16px;
      background:linear-gradient(180deg, #27e0ad 0%, #16c39b 100%);
      color:#052922; font-weight:900; text-transform:uppercase; letter-spacing:.6px;
      padding:10px 16px;
      box-shadow:0 8px 24px rgba(22,195,155,.35), inset 0 0 0 1px rgba(255,255,255,.15);
      transition: transform .08s ease, box-shadow .15s ease, filter .15s ease;
    }
    .btn.primary:hover{ filter:brightness(1.05); box-shadow:0 10px 28px rgba(22,195,155,.45), inset 0 0 0 1px rgba(255,255,255,.2); }
    .btn.primary:active{ transform:translateY(1px) scale(.995); }
    .btn.ghost{
      background:linear-gradient(180deg,#14222e,#0f171f);
      color:#cfe3f6; border:1px solid #253445; box-shadow:inset 0 0 0 1px rgba(255,255,255,.05);
      padding:10px 12px;
    }
    .btn.ghost:hover{ filter:brightness(1.06) }

    .iconbtn{appearance:none; border:1px solid #223243; background:#15202b; color:#cfe3f6; padding:10px 12px; border-radius:12px; cursor:pointer}

    .hud{position:fixed; left:16px; top:16px; z-index:5; display:flex; gap:12px; align-items:center; flex-wrap:wrap; backdrop-filter: blur(6px)}
    .pill{background:rgba(0,0,0,.35); border:1px solid #1f2a35; border-radius:999px; padding:6px 10px; font-size:13px; box-shadow:0 4px 10px rgba(0,0,0,.25)}
    .pill b{color:var(--accent)}

    /* micro info now at top-right */
    .micro{position:fixed; right:8px; top:2px; z-index:7; color:#fff; font-size:10px; line-height:1.2; opacity:.95; text-shadow:0 1px 2px rgba(0,0,0,.4); pointer-events:none; text-align:right}

    .crosshair{position:fixed; inset:0; pointer-events:none; display:grid; place-items:center; z-index:4}
    .crosshair svg{filter: drop-shadow(0 0 4px rgba(0,0,0,.8))}

    /* trail canvas below crosshair */
    #trail{position:fixed; inset:0; z-index:3; pointer-events:none}

    .end{position:fixed; inset:0; background:rgba(0,0,0,.55); z-index:19; display:none; align-items:center; justify-content:center}
    .end .card{background:#0f151d; border:1px solid #1b2632; border-radius:16px; padding:22px 26px; width:560px; box-shadow:0 18px 40px rgba(0,0,0,.45)}
    .end .card h2{margin:.2rem 0 .6rem; font-size:18px}
    .end .stat{display:flex; justify-content:space-between; padding:6px 0; color:#b7c7d6}
    .end .chart{margin-top:10px; padding:10px; border:1px solid #1b2632; border-radius:12px; background:linear-gradient(180deg,#0c1219,#0a0f15)}
    .end canvas{width:100%; height:180px; display:block}
    .end .actions{display:flex; gap:8px; margin-top:12px; justify-content:flex-end}

    .menu{position:fixed; inset:0; z-index:10; display:grid; place-items:center; background:linear-gradient(180deg,#0b0f15cc,#0b0f15ee)}
    .menu .card{width:min(760px,84vw); max-height:84vh; overflow:auto; background:linear-gradient(180deg,#111824,#0f151d); border:1px solid #1b2632; border-radius:18px; padding:12px 14px 14px; box-shadow:0 25px 60px rgba(0,0,0,.5); position:relative}
    .menu header{display:flex; align-items:center; justify-content:space-between; gap:10px; padding:8px 10px 12px; border-bottom:1px solid #1b2632}
    .menu header h1{margin:0; font-size:18px}

    .stage{padding:12px 6px}
    .modes{display:grid; grid-template-columns: repeat(3, 1fr); gap:12px}
    .mode-card{position:relative; display:flex; flex-direction:column; gap:8px; padding:16px; border-radius:16px; background:linear-gradient(180deg,#0e151e,#0b1016); border:1px solid #1a2430; min-height:140px; cursor:pointer; overflow:hidden}
    .mode-card::after{content:""; position:absolute; inset:auto -40px -40px auto; width:120px; height:120px; background:radial-gradient(closest-side, var(--accent2), transparent 70%); opacity:.18; transform:rotate(35deg)}
    .mode-card:hover{outline:1px solid #2a3b4c; box-shadow:0 12px 40px rgba(0,0,0,.35)}
    .mode-title{font-size:22px; letter-spacing:1px; font-weight:800}
    .mode-desc{color:#9bb1c4; font-size:13px; line-height:1.5}

    /* selection grids */
    .grid2{display:grid; grid-template-columns: repeat(2, 1fr); gap:10px}
    .grid4{display:grid; grid-template-columns: repeat(4, 1fr); gap:10px}

    .pick-card{min-height:120px; border-radius:16px; border:1px solid #1a2430; display:flex; align-items:center; justify-content:center; flex-direction:column; gap:8px; cursor:pointer; transition:transform .15s ease, box-shadow .15s ease, border-color .15s ease}
    .pick-card:hover{outline:1px solid #2a3b4c; box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .pick-card.selected{border-color:var(--accent); box-shadow:0 0 0 2px rgba(41,211,145,.5), 0 10px 30px rgba(0,0,0,.3)}
    .pick-title{font-size:22px; font-weight:800}
    .pick-desc{font-size:12px; color:#9db0c2}

    /* “压迫感”从左到右增强的绿色 */
    .tone-1{background:linear-gradient(180deg,#0f1922,#091018), linear-gradient(180deg, rgba(41,211,145,.10), rgba(41,211,145,.10))}
    .tone-2{background:linear-gradient(180deg,#0f1922,#091018), linear-gradient(180deg, rgba(41,211,145,.15), rgba(41,211,145,.15))}
    .tone-3{background:linear-gradient(180deg,#0f1922,#091018), linear-gradient(180deg, rgba(41,211,145,.20), rgba(41,211,145,.20))}
    .tone-4{background:linear-gradient(180deg,#0f1922,#091018), linear-gradient(180deg, rgba(41,211,145,.26), rgba(41,211,145,.26))}

    /* Settings modal and controls */
    .settings-modal{position:fixed; inset:0; z-index:18; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.45)}
    .settings-modal .card{width:min(760px,84vw); max-height:80vh; overflow:auto; background:linear-gradient(180deg,#111824,#0f151d); border:1px solid #1b2632; border-radius:18px; padding:12px 14px 14px; box-shadow:0 25px 60px rgba(0,0,0,.5); position:relative}
    .menu .grid{display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; padding:10px 4px}
    .menu .col{background:#0b1016; border:1px solid #1a2430; border-radius:14px; padding:10px}
    .menu h3{margin:2px 0 8px; font-size:14px; color:#9bb1c4; letter-spacing:.3px}

    /* 紧凑行距与更窄布局 */
    .row{display:grid; grid-template-columns:108px 1fr auto; align-items:center; column-gap:6px; row-gap:4px; padding:6px 0; min-height:36px}
    .label{font-size:12px; color:#8aa0b2;}
    .value{font-size:12px; color:#cfe3f6; padding:0; margin-left:2px}

    .ui-input{width:150px; padding:7px 10px; border-radius:10px; border:1px solid #223243; background:#0d1218; color:#e9eef3; outline:none}
    .ui-select{width:150px; padding:7px 10px; border-radius:10px; border:1px solid #223243; background:#0d1218; color:#e9eef3; outline:none; appearance:none; background-image:linear-gradient(45deg,transparent 50%,#7aa2c2 50%), linear-gradient(135deg,#7aa2c2 50%,transparent 50%); background-position:calc(100% - 18px) calc(1em - 2px), calc(100% - 12px) calc(1em - 2px); background-size:6px 6px, 6px 6px; background-repeat:no-repeat}

    .ui-slider{appearance:none; width:50%; height:6px; border-radius:999px; background:linear-gradient(90deg, var(--fill) var(--pct,0%), var(--track) 0); outline:none; border:1px solid #223243; justify-self:start}
    .ui-slider::-webkit-slider-thumb{appearance:none; width:16px; height:16px; border-radius:50%; background:var(--thumb); border:2px solid #0f151d; box-shadow:0 2px 6px rgba(0,0,0,.4)}
    .ui-slider::-moz-range-thumb{width:16px; height:16px; border-radius:50%; background:var(--thumb); border:2px solid #0f151d; box-shadow:0 2px 6px rgba(0,0,0,.4)}

    /* Tips, errors, overlays */
    .tips{position:fixed; bottom:10px; left:50%; transform:translateX(-50%); z-index:6; font-size:12px; color:#9db0c2; opacity:.9}
    .error{position:fixed; inset:auto 16px 16px 16px; z-index:12; background:#2b1d1d; color:#ffd6d6; border:1px solid #5a2a2a; border-radius:12px; padding:10px 12px; display:none}

    /* Ready (3s) overlay */
    .ready{position:fixed; inset:0; z-index:15; display:none; align-items:center; justify-content:center; pointer-events:none}
    .ready .bubble{font-size:72px; font-weight:900; color:#e9eef3; text-shadow:0 8px 30px rgba(0,0,0,.55)}
    .ready .sub{font-size:14px; color:#9db0c2; margin-top:8px; text-align:center}

    /* Floating +100 */
    .float-layer{position:fixed; inset:0; pointer-events:none; z-index:16}
    .float{position:absolute; font-weight:800; color:#e9fdf5; text-shadow:0 2px 12px rgba(0,0,0,.65); opacity:0; transform:translate(-50%,-50%) translateY(8px); animation:floatFade 700ms ease-out forwards}
    @keyframes floatFade{
      0%{opacity:0; transform:translate(-50%,-50%) translateY(8px)}
      15%{opacity:1}
      100%{opacity:0; transform:translate(-50%,-50%) translateY(-22px)}
    }

    /* Crosshair preview box */
    .cross-prev{width:140px; height:100px; border-radius:10px; border:1px solid #1b2632; background:radial-gradient(160px 80px at 50% 50%, #0f151d 0%, #0b1016 100%); display:grid; place-items:center}
    .cross-prev svg{filter: drop-shadow(0 0 4px rgba(0,0,0,.7))}
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <canvas id="game"></canvas>
  <canvas id="trail"></canvas>

  <div class="mobile-block" id="mobileBlock">
    <div class="box">
      <h2>❌不支持移动设备访问</h2>
      <p>为获得最佳体验，请在桌面浏览器中打开。</p>
    </div>
  </div>

  <div class="hud" id="hud">
    <div class="pill">模式：<b id="hudMode">—</b></div>
    <div class="pill">时间：<b id="hudTime">60.0</b>s</div>
    <div class="pill">分数：<b id="hudScore">0</b></div>
    <div class="pill">命中：<b id="hudHits">0</b></div>
    <div class="pill">射击：<b id="hudShots">0</b></div>
    <div class="pill">命中率：<b id="hudAcc">0%</b></div>
  </div>

  <div id="microInfo" class="micro" style="display:none"></div>

  <div class="crosshair" id="crosshair"></div>

  <!-- 独立结算页（移除“再来一局”按钮） -->
  <div class="end" id="end">
    <div class="card">
      <h2>本局结束</h2>
      <div class="stat"><span>模式</span><b id="endMode">—</b></div>
      <div class="stat"><span>分数</span><b id="endScore">0</b></div>
      <div class="stat" id="rowHM"><span>命中 / 射击</span><b id="endHM">0 / 0</b></div>
      <div class="stat" id="rowACC"><span>命中率</span><b id="endAcc">0%</b></div>
      <div class="stat" id="rowStreak"><span>最佳连击</span><b id="endStreak">0</b></div>
      <div class="stat" id="endTrackingTimeRow" style="display:none"><span>跟踪命中时间</span><b id="endTrackTime">0.00 s</b></div>
      <div class="chart">
        <div style="display:flex; justify-content:space-between; align-items:center;">
          <div style="font-size:13px; color:#9db0c2">得分效率（每5秒）</div>
          <div id="endBucketsLabel" style="font-size:12px; color:#7fa6c3"></div>
        </div>
        <canvas id="endChart" width="520" height="180"></canvas>
      </div>
      <div class="actions">
        <button class="btn ghost" id="endToMenu">返回菜单</button>
        <button class="btn ghost" id="closeEnd">关闭</button>
      </div>
    </div>
  </div>

  <!-- Menu -->
  <div class="menu" id="menu">
    <div class="card">
      <header>
        <h1>AimStudio</h1>
        <div style="display:flex; align-items:center; gap:8px">
          <small></small>
          <button id="openSettings" class="iconbtn" title="设置">⚙</button>
        </div>
      </header>

      <!-- Stage 1: Modes -->
      <section id="stageModes" class="stage modes">
        <div class="mode-card" data-mode="gridshot">
          <div class="mode-title">GRIDSHOT</div>
          <div class="mode-desc">多目标快速切换</div>
        </div>
        <div class="mode-card" data-mode="spidershot">
          <div class="mode-title">SPIDERSHOT</div>
          <div class="mode-desc">准确定位练习</div>
        </div>
        <div class="mode-card" data-mode="tracking">
          <div class="mode-title">TRACKING</div>
          <div class="mode-desc">平行线或随机移动跟枪</div>
        </div>
      </section>

      <!-- Gridshot：目标数量选择 -->
      <section id="stageCounts" class="stage" style="display:none">
        <div style="font-size:14px; color:#9bb1c4; margin-bottom:2px">选择同时存在的目标数量</div>
        <div class="grid4">
          <div class="pick-card tone-1" data-count="3"><div class="pick-title">3</div><div class="pick-desc">基础</div></div>
          <div class="pick-card tone-2" data-count="4"><div class="pick-title">4</div><div class="pick-desc">密集</div></div>
          <div class="pick-card tone-3" data-count="5"><div class="pick-title">5</div><div class="pick-desc">强度</div></div>
          <div class="pick-card tone-4" data-count="6"><div class="pick-title">6</div><div class="pick-desc">极限</div></div>
        </div>
        <div class="actions" style="justify-content:flex-end; border-top:1px solid #1b2632; padding-top:8px; display:flex; gap:10px; margin-top:12px">
          <button id="countsBack" class="btn ghost">返回</button>
          <button id="countsStart" class="btn primary">开始训练</button>
        </div>
      </section>

      <!-- Tracking：移动方式选择 -->
      <section id="stageTrackType" class="stage" style="display:none">
        <div style="font-size:14px; color:#9bb1c4; margin-bottom:8px">选择 Tracking 的移动方式</div>
        <div class="grid2">
          <div class="pick-card tone-1" data-track="parallel"><div class="pick-title">平行</div><div class="pick-desc">同一高度平行跟枪练习</div></div>
          <div class="pick-card tone-3" data-track="random"><div class="pick-title">随机</div><div class="pick-desc">平面内随机跟枪练习</div></div>
        </div>
        <div class="actions" style="justify-content:flex-end; border-top:1px solid #1b2632; padding-top:8px; display:flex; gap:10px; margin-top:12px">
          <button id="trackBack" class="btn ghost">返回</button>
          <button id="trackStart" class="btn primary">开始训练</button>
        </div>
      </section>

      <!-- Spidershot：路径显示选择 -->
      <section id="stageSpiderPath" class="stage" style="display:none">
        <div style="font-size:14px; color:#9bb1c4; margin-bottom:8px">Spidershot 轨迹显示</div>
        <div class="grid2">
          <div class="pick-card tone-1" data-path="hide"><div class="pick-title">隐藏路径</div><div class="pick-desc">不显示练习用拖尾</div></div>
          <div class="pick-card tone-3" data-path="show"><div class="pick-title">显示路径</div><div class="pick-desc">显示练习用拖尾以便纠正鼠标路径</div></div>
        </div>
        <div class="actions" style="justify-content:flex-end; border-top:1px solid #1b2632; padding-top:8px; display:flex; gap:10px; margin-top:12px">
          <button id="spiderBack" class="btn ghost">返回</button>
          <button id="spiderStart" class="btn primary">开始训练</button>
        </div>
      </section>
    </div>
  </div>

  <!-- Settings modal -->
  <div class="settings-modal" id="settingsModal">
    <div class="card">
      <header style="display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px 8px 10px; border-bottom:1px solid #1b2632">
        <h1>设置</h1>
        <div style="display:flex; gap:8px; align-items:center">
          <button id="saveSettings" class="btn primary">保存设置</button>
          <button id="m_reset" class="iconbtn" title="恢复默认">默认</button>
          <button id="closeSettings" class="iconbtn">关闭</button>
        </div>
      </header>
      <div class="grid">
        <div class="col">
          <h3>基础</h3>
          <div class="row">
            <span class="label">FOV</span>
            <input id="m_fov" type="number" class="ui-input" min="60" max="110" step="1" value="80">
            <span></span>
          </div>
          <div class="row">
            <span class="label">靶距离</span>
            <select id="m_dist" class="ui-select" title="近:-15 / 中:-25 / 远:-40">
              <option value="near">近</option>
              <option value="mid" selected>中</option>
              <option value="far">远</option>
            </select>
            <span></span>
          </div>
          <div class="row">
            <span class="label">Z 随机</span>
            <select id="m_randZ" class="ui-select">
              <option value="off">关闭</option>
              <option value="on">开启</option>
            </select>
            <span></span>
          </div>
        </div>

        <div class="col">
          <h3>目标</h3>
          <div class="row"><span class="label">大小</span>
            <input id="m_targetSize" class="ui-slider" type="range" min="0.3" max="1.6" step="0.05" value="0.8">
            <span id="valTargetSize" class="value">0.80</span>
          </div>
          <div class="row"><span class="label">目标速度</span>
            <input id="m_targetSpeed" class="ui-slider" type="range" min="0.5" max="15" step="0.5" value="6">
            <span id="valTargetSpeed" class="value">6.0</span>
          </div>
        </div>

        <div class="col">
          <h3>反馈与准星</h3>

          <div class="row">
            <span class="label">准星预览</span>
            <div class="cross-prev" id="crossPreview"></div>
            <span></span>
          </div>

          <div class="row"><span class="label">浮动分数</span>
            <select id="m_floatScore" class="ui-select">
              <option value="on" selected>开启</option>
              <option value="off">关闭</option>
            </select>
            <span></span>
          </div>

          <div class="row"><span class="label">命中音效</span>
            <select id="m_hitSound" class="ui-select">
              <option value="beep1" selected>Beep 1</option>
              <option value="beep2">Beep 2</option>
              <option value="beep3">Beep 3</option>
              <option value="beep4">Beep 4</option>
              <option value="beep5">Beep 5</option>
              <option value="off">关闭</option>
            </select>
            <button id="m_testHit" class="btn ghost" title="试听">▶ 试听</button>
          </div>

          <div class="row"><span class="label">准星样式</span>
            <select id="m_crossStyle" class="ui-select">
              <option value="dot">圆点</option>
              <option value="cross" selected>十字（默认）</option>
              <option value="circle">圆环</option>
              <option value="t">T 形</option>
            </select>
            <span></span>
          </div>
          <div class="row"><span class="label">准星大小</span>
            <input id="m_crossSize" class="ui-slider" type="range" min="6" max="40" step="1" value="14">
            <span id="valCrossSize" class="value">14</span>
          </div>
          <div class="row"><span class="label">准星粗细</span>
            <input id="m_crossThick" class="ui-slider" type="range" min="1" max="6" step="1" value="2">
            <span id="valCrossThick" class="value">2</span>
          </div>
          <div class="row"><span class="label">准星间隙</span>
            <input id="m_crossGap" class="ui-slider" type="range" min="0" max="16" step="1" value="4">
            <span id="valCrossGap" class="value">4</span>
          </div>
          <div class="row"><span class="label">准星透明度</span>
            <input id="m_crossAlpha" class="ui-slider" type="range" min="0.2" max="1" step="0.05" value="0.95">
            <span id="valCrossAlpha" class="value">0.95</span>
          </div>
          <div class="row"><span class="label">准星颜色</span>
            <input id="m_crossColor" class="ui-input" type="color" value="#ffffff" style="height:32px; width:56px; padding:0 4px">
            <span></span>
          </div>
          <div class="row"><span class="label">灵敏度 X</span>
            <input id="m_sensX" class="ui-slider" type="range" min="0.2" max="2.5" step="0.05" value="1.0">
            <span id="valSensX" class="value">1.00</span>
          </div>
          <div class="row"><span class="label">灵敏度 Y</span>
            <input id="m_sensY" class="ui-slider" type="range" min="0.2" max="2.5" step="0.05" value="1.0">
            <span id="valSensY" class="value">1.00</span>
          </div>
          <div class="row"><span class="label">鼠标加速度</span>
            <input id="m_accel" class="ui-slider" type="range" min="0" max="0.05" step="0.001" value="0">
            <span id="valAccel" class="value">0.000</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="tips">按Alt随时中止训练 - PoweredBySnowV3</div>
  <div id="err" class="error"></div>

  <!-- 3秒准备层 & 浮分层 -->
  <div id="readyLayer" class="ready">
    <div style="text-align:center">
      <div class="bubble" id="readyNum">3</div>
      <div class="sub">准备就绪...</div>
    </div>
  </div>
  <div id="floatLayer" class="float-layer"></div>

  <script type="module">
    import * as THREE from 'three';

    // --- Mobile detect ---
    const mobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || matchMedia('(pointer:coarse)').matches;
    if(mobile){
      const blk = document.getElementById('mobileBlock');
      blk.style.display = 'flex';
    }

    const canvas = document.getElementById('game');
    const trailCanvas = document.getElementById('trail');
    const tctx = trailCanvas.getContext('2d');
    function sizeTrail() {
      const dpr = Math.min(window.devicePixelRatio||1, 2);
      trailCanvas.width = Math.floor(innerWidth * dpr);
      trailCanvas.height = Math.floor(innerHeight * dpr);
      trailCanvas.style.width = innerWidth + 'px';
      trailCanvas.style.height = innerHeight + 'px';
      tctx.setTransform(dpr,0,0,dpr,0,0);
    }
    sizeTrail();

    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0c0f14);

    const camera = new THREE.PerspectiveCamera(80, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 0);
    camera.rotation.order = 'YXZ';

    // v4-style lighting
    const hemi = new THREE.HemisphereLight(0xffffff, 0x334455, 0.55);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(6, 10, -4);
    scene.add(dir);

    // ------- Room -------
    const ROOM_W = 26, ROOM_H = 12, ROOM_D = 44;
    const FRONT_D = 12;
    const room = new THREE.Group();
    const floorMat = new THREE.MeshStandardMaterial({color:0x182028, roughness:0.95, metalness:0.05});
    const wallMat = new THREE.MeshStandardMaterial({color:0x0e141b, roughness:1});
    function plane(w,h,mat){ return new THREE.Mesh(new THREE.PlaneGeometry(w,h), mat.clone()); }
    const floorBack = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_W, ROOM_D, 26, 44), floorMat);
    floorBack.rotation.x = -Math.PI/2; floorBack.position.set(0,0,-ROOM_D/2);
    const backWall = plane(ROOM_W, ROOM_H, wallMat); backWall.position.set(0, ROOM_H/2, -ROOM_D);
    const leftWallBack = plane(ROOM_D, ROOM_H, wallMat); leftWallBack.rotation.y = Math.PI/2; leftWallBack.position.set(-ROOM_W/2, ROOM_H/2, -ROOM_D/2);
    const rightWallBack= plane(ROOM_D, ROOM_H, wallMat); rightWallBack.rotation.y = -Math.PI/2; rightWallBack.position.set( ROOM_W/2, ROOM_H/2, -ROOM_D/2);
    const ceilBack = plane(ROOM_W, ROOM_D, wallMat); ceilBack.rotation.x = Math.PI/2; ceilBack.position.set(0, ROOM_H, -ROOM_D/2);
    const floorFront = new THREE.Mesh(new THREE.PlaneGeometry(ROOM_W, FRONT_D, 26, 10), floorMat);
    floorFront.rotation.x = -Math.PI/2; floorFront.position.set(0,0, FRONT_D/2);
    const frontWall = plane(ROOM_W, ROOM_H, wallMat); frontWall.position.set(0, ROOM_H/2, FRONT_D);
    const leftWallFront = plane(FRONT_D, ROOM_H, wallMat); leftWallFront.rotation.y = Math.PI/2; leftWallFront.position.set(-ROOM_W/2, ROOM_H/2, FRONT_D/2);
    const rightWallFront= plane(FRONT_D, ROOM_H, wallMat); rightWallFront.rotation.y = -Math.PI/2; rightWallFront.position.set( ROOM_W/2, ROOM_H/2, FRONT_D/2);
    const ceilFront = plane(ROOM_W, FRONT_D, wallMat); ceilFront.rotation.x = Math.PI/2; ceilFront.position.set(0, ROOM_H, FRONT_D/2);
    room.add(floorBack, backWall, leftWallBack, rightWallBack, ceilBack, floorFront, frontWall, leftWallFront, rightWallFront, ceilFront);
    scene.add(room);

    // Back wall grid
    const grid = new THREE.Group();
    const gridColor = new THREE.Color(0x22303b);
    const lineMat = new THREE.LineBasicMaterial({color: gridColor});
    for(let i=0;i<=5;i++){
      const x = -ROOM_W/2 + (i/5)*ROOM_W;
      const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(x, 1.5, -ROOM_D+0.01), new THREE.Vector3(x, ROOM_H-0.5, -ROOM_D+0.01)]);
      grid.add(new THREE.Line(geo, lineMat));
    }
    for(let j=0;j<=3;j++){
      const y = 1.5 + (j/3)*(ROOM_H-2);
      const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(-ROOM_W/2, y, -ROOM_D+0.01), new THREE.Vector3( ROOM_W/2, y, -ROOM_D+0.01)]);
      grid.add(new THREE.Line(geo, lineMat));
    }
    scene.add(grid);

    // ------- Gun -------
    const gun = new THREE.Group();
    const gunBody = new THREE.Mesh(new THREE.BoxGeometry(0.18,0.12,0.32), new THREE.MeshStandardMaterial({color:0x1c1c1e, metalness:0.7, roughness:0.35}));
    const gunBarrel = new THREE.Mesh(new THREE.CylinderGeometry(0.025,0.025,0.35, 18), new THREE.MeshStandardMaterial({color:0x444, metalness:0.8, roughness:0.25}));
    gunBarrel.rotation.x = Math.PI/2; gunBarrel.position.set(0.06,0.02,-0.28);
    gun.add(gunBody, gunBarrel);
    const gunPivot = new THREE.Group();
    gunPivot.position.set(0.45, -0.35, -0.6);
    gunPivot.add(gun);
    camera.add(gunPivot);

    // ------- Targets -------
    const baseMat = new THREE.MeshStandardMaterial({color:0x45b7ff, emissive:0x0a3c66, metalness:0.3, roughness:0.3});
    const hitMat  = new THREE.MeshStandardMaterial({color:0x29d391, emissive:0x0f6a4f, metalness:0.3, roughness:0.3});
    const targets = new THREE.Group(); scene.add(targets);

    // Particles layer (Type 1 only)
    const particleLayer = new THREE.Group(); scene.add(particleLayer);
    const particleClouds = [];

    const raycaster = new THREE.Raycaster();
    const center = new THREE.Vector2(0,0);

    // ------- Audio -------
    let audioCtx;
    function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)(); return audioCtx; }
    function playHit(kind='beep1', vol=0.05, len=70){
      if(kind==='off') return;
      const ac = ensureAudio();
      if(kind==='beep4'){
        const dur = Math.max(0.02, len/1000);
        const bufferSize = ac.sampleRate * dur;
        const buffer = ac.createBuffer(1, bufferSize, ac.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0;i<bufferSize;i++){ data[i] = (Math.random()*2-1) * (1 - i/bufferSize); }
        const src = ac.createBufferSource(); src.buffer = buffer;
        const g = ac.createGain(); g.gain.value = vol*0.7;
        src.connect(g); g.connect(ac.destination); src.start();
      }else if(kind==='beep5'){
        const o1 = ac.createOscillator(), o2 = ac.createOscillator();
        const g = ac.createGain(); g.gain.value = vol*0.7;
        o1.type='square'; o2.type='triangle'; o1.frequency.value=620; o2.frequency.value=1240;
        o1.connect(g); o2.connect(g); g.connect(ac.destination);
        o1.start(); o2.start();
        setTimeout(()=>{o1.stop();o2.stop();}, len);
      }else if(kind==='beep3'){
        const o = ac.createOscillator(); const g = ac.createGain();
        o.type='sine'; o.frequency.value=800;
        const end = ac.currentTime + Math.max(0.02, len/1000);
        o.frequency.linearRampToValueAtTime(1250, end);
        g.gain.value=vol*0.8; o.connect(g); g.connect(ac.destination);
        o.start(); setTimeout(()=>o.stop(), len);
      }else if(kind==='beep2'){
        const o = ac.createOscillator(); const g = ac.createGain();
        o.type='triangle'; o.frequency.value=900;
        g.gain.value=vol*0.9; o.connect(g); g.connect(ac.destination);
        o.start(); setTimeout(()=>o.stop(), len);
      }else{ // beep1 default
        const o = ac.createOscillator(); const g = ac.createGain();
        const b = ac.createBiquadFilter(); b.type='highpass'; b.frequency.value=600;
        o.type='square'; o.frequency.value=1100; g.gain.value=vol;
        o.connect(b); b.connect(g); g.connect(ac.destination);
        o.start(); setTimeout(()=>o.stop(), len);
      }
    }
    function playMiss(vol=0.03, len=60){
      if(menu.hitSound.value==='off') return;
      const ac = ensureAudio();
      const o = ac.createOscillator(); const g = ac.createGain();
      o.type='sine'; o.frequency.value=160; g.gain.value=vol; o.connect(g); g.connect(ac.destination);
      o.start(); setTimeout(()=>o.stop(), len);
    }

    // ------- HUD refs -------
    const hud = {
      mode: document.getElementById('hudMode'),
      time: document.getElementById('hudTime'),
      score: document.getElementById('hudScore'),
      hits: document.getElementById('hudHits'),
      shots: document.getElementById('hudShots'),
      acc: document.getElementById('hudAcc')
    };
    const micro = document.getElementById('microInfo');

    // ------- Menu / Settings refs -------
    const menu = {
      root: document.getElementById('menu'),
      stageModes: document.getElementById('stageModes'),
      stageTrackType: document.getElementById('stageTrackType'),
      stageCounts: document.getElementById('stageCounts'),
      stageSpiderPath: document.getElementById('stageSpiderPath'),
      openSettings: document.getElementById('openSettings'),
      settingsModal: document.getElementById('settingsModal'),
      closeSettings: document.getElementById('closeSettings'),
      // gridshot
      countsBack: document.getElementById('countsBack'),
      countsStart: document.getElementById('countsStart'),
      // tracking
      trackBack: document.getElementById('trackBack'),
      trackStart: document.getElementById('trackStart'),
      // spidershot
      spiderBack: document.getElementById('spiderBack'),
      spiderStart: document.getElementById('spiderStart'),
      // header controls
      reset: document.getElementById('m_reset'),
      saveSettings: document.getElementById('saveSettings'),
      // Settings controls
      fov: document.getElementById('m_fov'),
      dist: document.getElementById('m_dist'),
      randZ: document.getElementById('m_randZ'),
      targetSize: document.getElementById('m_targetSize'),
      targetSpeed: document.getElementById('m_targetSpeed'),
      floatScore: document.getElementById('m_floatScore'),
      hitSound: document.getElementById('m_hitSound'),
      testHit: document.getElementById('m_testHit'),
      crossStyle: document.getElementById('m_crossStyle'),
      crossSize: document.getElementById('m_crossSize'),
      crossThick: document.getElementById('m_crossThick'),
      crossGap: document.getElementById('m_crossGap'),
      crossAlpha: document.getElementById('m_crossAlpha'),
      crossColor: document.getElementById('m_crossColor'),
      sensX: document.getElementById('m_sensX'),
      sensY: document.getElementById('m_sensY'),
      accel: document.getElementById('m_accel'),
      // value labels
      valTargetSize: document.getElementById('valTargetSize'),
      valTargetSpeed: document.getElementById('valTargetSpeed'),
      valCrossSize: document.getElementById('valCrossSize'),
      valCrossThick: document.getElementById('valCrossThick'),
      valCrossGap: document.getElementById('valCrossGap'),
      valCrossAlpha: document.getElementById('valCrossAlpha'),
      valSensX: document.getElementById('valSensX'),
      valSensY: document.getElementById('valSensY'),
      valAccel: document.getElementById('valAccel'),
      crossPrev: document.getElementById('crossPreview')
    };

    const ui = {
      crosshair: document.getElementById('crosshair'),
      end: document.getElementById('end'),
      endMode: document.getElementById('endMode'),
      endScore: document.getElementById('endScore'),
      rowHM: document.getElementById('rowHM'),
      endHM: document.getElementById('endHM'),
      rowACC: document.getElementById('rowACC'),
      endAcc: document.getElementById('endAcc'),
      rowStreak: document.getElementById('rowStreak'),
      endStreak: document.getElementById('endStreak'),
      endTrackingTimeRow: document.getElementById('endTrackingTimeRow'),
      endTrackTime: document.getElementById('endTrackTime'),
      endToMenu: document.getElementById('endToMenu'),
      closeEnd: document.getElementById('closeEnd'),
      hud: document.getElementById('hud'),
      err: document.getElementById('err'),
      readyLayer: document.getElementById('readyLayer'),
      readyNum: document.getElementById('readyNum'),
      floatLayer: document.getElementById('floatLayer'),
      endBucketsLabel: document.getElementById('endBucketsLabel'),
      endChart: document.getElementById('endChart')
    };

    // Simple default difficulty kept internally (B)
    const DifficultyIntervals = { D:1.2, C:0.9, B:0.7, A:0.5, S:0.35 };
    const TrackChangeByDiff = {
      D:[0.9,1.5],
      C:[0.7,1.2],
      B:[0.5,1.0],
      A:[0.35,0.8],
      S:[0.22,0.6]
    };

    // Z 映射
    const DistMap = { near:-15, mid:-25, far:-40 };

    // ------- Settings & State -------
    const Settings = {
      mode: 'gridshot',
      difficulty: 'B',          // 固定默认，已无选择界面
      trackType: 'random',      // 'parallel' | 'random'
      spiderTrail: 'hide',      // 'hide' | 'show'
      showTrail: false,         // bool 派生
      duration: 60,
      fov: 80,
      dist: 'mid',
      fixedZ: -25,
      randZ: false,
      targetSize: 0.8,
      targetSpeed: 6,
      minSeparation: 1.8,
      crossStyle: 'cross',
      crossSize: 14,
      crossThick: 2,
      crossGap: 4,
      crossAlpha: 0.95,
      crossColor: '#ffffff',
      sensX: 1.0,
      sensY: 1.0,
      accel: 0.0,
      floatScore: true,
      hitSound: 'beep1',
      maxTargets: 3
    };

    const State = {
      running: false,
      phase: 'menu',
      readyLeft: 3.0,
      timeLeft: 60,
      score: 0,
      _scorePrev: 0,
      scoreBuckets: [],
      hits: 0,
      shots: 0,
      streak: 0,
      bestStreak: 0,
      trackingOnTargetTime: 0,
      totalTrackingTime: 0,
      currentTarget: null,
      lastTime: performance.now(),
      yaw: 0,
      pitch: 0,
      locked: false,
      pickedMode: 'gridshot',
      pickedTargets: 3,
      pickedTrackType: 'random',
      pickedSpiderPath: 'hide',
      trkSfxTimer: 0,
      mouseSpeed: 0,
      _lastMouseTime: performance.now(),
      pointerPos: {x: innerWidth/2, y: innerHeight/2},
      trailPts: []
    };

    const LS_KEY = 'aim_fps_settings_v12';
    function saveSettings(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(Settings)); }catch(e){} }
    function loadSettings(){
      try{
        const raw = localStorage.getItem(LS_KEY);
        if(!raw) return;
        const data = JSON.parse(raw);
        Object.assign(Settings, data);
        if(!Settings.dist){
          if(Settings.fixedZ<=-35) Settings.dist='far';
          else if(Settings.fixedZ<=-20) Settings.dist='mid';
          else Settings.dist='near';
        }
        Settings.fixedZ = DistMap[Settings.dist];
        Settings.showTrail = (Settings.spiderTrail === 'show');
      }catch(e){}
    }

    // --------- UI helpers ----------
    function applySettings(){
      Settings.fov = Math.max(60, Math.min(110, parseInt(menu.fov.value)||80));
      Settings.dist = menu.dist.value;
      Settings.fixedZ = DistMap[Settings.dist];
      Settings.randZ = (menu.randZ.value === 'on');
      Settings.targetSize = parseFloat(menu.targetSize.value);
      Settings.targetSpeed = parseFloat(menu.targetSpeed.value);
      Settings.floatScore = (menu.floatScore.value === 'on');
      Settings.hitSound = menu.hitSound.value;
      Settings.crossStyle = menu.crossStyle.value;
      Settings.crossSize = parseInt(menu.crossSize.value);
      Settings.crossThick = parseInt(menu.crossThick.value);
      Settings.crossGap = parseInt(menu.crossGap.value);
      Settings.crossAlpha = parseFloat(menu.crossAlpha.value);
      Settings.crossColor = menu.crossColor.value;
      Settings.sensX = parseFloat(menu.sensX.value);
      Settings.sensY = parseFloat(menu.sensY.value);
      Settings.accel = parseFloat(menu.accel.value);
      drawCrosshairOverlays();
      updateValueBadges();
      styleAllSliders();
      saveSettings();
    }
    function resetControlsFromSettings(){
      menu.fov.value = Settings.fov;
      menu.dist.value = Settings.dist;
      menu.randZ.value = Settings.randZ ? 'on' : 'off';
      menu.targetSize.value = Settings.targetSize;
      menu.targetSpeed.value = Settings.targetSpeed;
      menu.floatScore.value = Settings.floatScore ? 'on' : 'off';
      menu.hitSound.value = Settings.hitSound;
      menu.crossStyle.value = Settings.crossStyle;
      menu.crossSize.value = Settings.crossSize;
      menu.crossThick.value = Settings.crossThick;
      menu.crossGap.value = Settings.crossGap;
      menu.crossAlpha.value = Settings.crossAlpha;
      menu.crossColor.value = Settings.crossColor;
      menu.sensX.value = Settings.sensX;
      menu.sensY.value = Settings.sensY;
      menu.accel.value = Settings.accel;
      updateValueBadges();
      styleAllSliders();
      drawCrosshairOverlays();
    }
    function resetToDefault(){
      Object.assign(Settings, {
        mode: 'gridshot',
        difficulty: 'B',
        trackType: 'random',
        spiderTrail: 'hide',
        showTrail: false,
        duration: 60,
        fov: 80,
        dist: 'mid',
        fixedZ: -25,
        randZ: false,
        targetSize: 0.8,
        targetSpeed: 6,
        minSeparation: 1.8,
        crossStyle: 'cross',
        crossSize: 14,
        crossThick: 2,
        crossGap: 4,
        crossAlpha: 0.95,
        crossColor: '#ffffff',
        sensX: 1.0,
        sensY: 1.0,
        accel: 0.0,
        floatScore: true,
        hitSound: 'beep1',
        maxTargets: 3
      });
      applySettings(); resetControlsFromSettings();
    }

    function setSliderPct(el){
      const min = parseFloat(el.min||0), max = parseFloat(el.max||100), val = parseFloat(el.value||0);
      const pct = ((val - min) * 100) / (max - min);
      el.style.setProperty('--pct', pct + '%');
    }
    function styleAllSliders(){ document.querySelectorAll('.ui-slider').forEach(setSliderPct); }

    function updateValueBadges(){
      menu.valTargetSize.textContent = (+menu.targetSize.value).toFixed(2);
      menu.valTargetSpeed.textContent = (+menu.targetSpeed.value).toFixed(1);
      menu.valCrossSize.textContent = (+menu.crossSize.value).toFixed(0);
      menu.valCrossThick.textContent = (+menu.crossThick.value).toFixed(0);
      menu.valCrossGap.textContent = (+menu.crossGap.value).toFixed(0);
      menu.valCrossAlpha.textContent = (+menu.crossAlpha.value).toFixed(2);
      menu.valSensX.textContent = (+menu.sensX.value).toFixed(2);
      menu.valSensY.textContent = (+menu.sensY.value).toFixed(2);
      menu.valAccel.textContent = (+menu.accel.value).toFixed(3);
    }

    // --------- Menu stages ----------
    function showMenu(){
      State.running = false; State.phase='menu';
      document.exitPointerLock?.();
      menu.root.style.display = 'grid';
      menu.stageModes.style.display = 'grid';
      menu.stageTrackType.style.display = 'none';
      menu.stageCounts.style.display = 'none';
      menu.stageSpiderPath.style.display = 'none';
      document.getElementById('hud').style.display = 'none';
      micro.style.display = 'none';
      ui.end.style.display = 'none';
      ui.readyLayer.style.display = 'none';
    }
    function hideMenu(){
      menu.root.style.display = 'none';
      document.getElementById('hud').style.display = 'flex';
    }

    // Mode select click
    document.querySelectorAll('.mode-card').forEach(card=>{
      card.addEventListener('click', ()=>{
        const mode = card.getAttribute('data-mode');
        State.pickedMode = mode;
        Settings.mode = mode;
        if(mode==='gridshot'){ // counts -> start
          menu.stageModes.style.display='none';
          menu.stageCounts.style.display='block';
          updateCountHighlight();
        }else if(mode==='tracking'){ // trackType -> start
          menu.stageModes.style.display='none';
          menu.stageTrackType.style.display='block';
          updateTrackTypeHighlight();
        }else{ // spidershot -> path select -> start
          menu.stageModes.style.display='none';
          menu.stageSpiderPath.style.display='block';
          updateSpiderPathHighlight();
        }
      });
    });

    // Gridshot counts stage
    function updateCountHighlight(){
      document.querySelectorAll('#stageCounts .pick-card').forEach(p=>{
        const c = parseInt(p.getAttribute('data-count'));
        p.classList.toggle('selected', c===State.pickedTargets);
      });
    }
    document.querySelectorAll('#stageCounts .pick-card').forEach(pill=>{
      pill.addEventListener('click', ()=>{
        const c = parseInt(pill.getAttribute('data-count'));
        State.pickedTargets = c;
        Settings.maxTargets = c;
        updateCountHighlight();
      });
    });
    menu.countsBack.addEventListener('click', ()=>{
      menu.stageCounts.style.display='none';
      menu.stageModes.style.display='grid';
    });
    menu.countsStart.addEventListener('click', ()=> startRun());

    // Tracking type stage
    function updateTrackTypeHighlight(){
      document.querySelectorAll('#stageTrackType .pick-card').forEach(card=>{
        const t = card.getAttribute('data-track');
        card.classList.toggle('selected', t===State.pickedTrackType);
      });
    }
    document.querySelectorAll('#stageTrackType .pick-card').forEach(card=>{
      card.addEventListener('click', ()=>{
        State.pickedTrackType = card.getAttribute('data-track');
        Settings.trackType = State.pickedTrackType;
        updateTrackTypeHighlight();
      });
    });
    menu.trackBack.addEventListener('click', ()=>{
      menu.stageTrackType.style.display='none';
      menu.stageModes.style.display='grid';
    });
    menu.trackStart.addEventListener('click', ()=> startRun());

    // Spidershot path stage
    function updateSpiderPathHighlight(){
      document.querySelectorAll('#stageSpiderPath .pick-card').forEach(card=>{
        const p = card.getAttribute('data-path');
        card.classList.toggle('selected', p===State.pickedSpiderPath);
      });
    }
    document.querySelectorAll('#stageSpiderPath .pick-card').forEach(card=>{
      card.addEventListener('click', ()=>{
        State.pickedSpiderPath = card.getAttribute('data-path');
        Settings.spiderTrail = State.pickedSpiderPath;
        Settings.showTrail = (Settings.spiderTrail === 'show');
        updateSpiderPathHighlight();
      });
    });
    menu.spiderBack.addEventListener('click', ()=>{
      menu.stageSpiderPath.style.display='none';
      menu.stageModes.style.display='grid';
    });
    menu.spiderStart.addEventListener('click', ()=> startRun());

    // Settings modal
    menu.openSettings.addEventListener('click', ()=>{ menu.settingsModal.style.display='flex'; resetControlsFromSettings(); });
    menu.closeSettings.addEventListener('click', ()=>{ menu.settingsModal.style.display='none'; });
    menu.saveSettings.addEventListener('click', ()=>{ applySettings(); menu.settingsModal.style.display='none'; drawCrosshairOverlays(); });
    menu.reset.addEventListener('click', ()=>{ resetToDefault(); });

    // 试听命中音效
    menu.testHit.addEventListener('click', ()=>{ playHit(menu.hitSound.value, 0.06, 100); });

    // Live reflect changes
    ['input','change'].forEach(evt=>{
      [menu.fov,menu.dist,menu.randZ,menu.targetSize,menu.targetSpeed,menu.floatScore,menu.hitSound,menu.crossStyle,menu.crossSize,menu.crossThick,menu.crossGap,menu.crossAlpha,menu.crossColor,menu.sensX,menu.sensY,menu.accel].forEach(el=>{
        el.addEventListener(evt, ()=>{ applySettings(); });
      });
    });

    // --------- Crosshair ----------
    function crosshairSVG(s){
      const size = s.crossSize, thick = s.crossThick, gap = s.crossGap, col = s.crossColor, alpha = s.crossAlpha;
      let svg = ''; const half = 32;
      if(s.crossStyle==='dot'){
        svg += `<circle cx="${half}" cy="${half}" r="${Math.max(2, size/3)}" fill="${col}" fill-opacity="${alpha}" />`;
      } else if(s.crossStyle==='cross'){
        svg += `<rect x="${half - (gap+size)}" y="${half - thick/2}" width="${size}" height="${thick}" fill="${col}" fill-opacity="${alpha}" />`;
        svg += `<rect x="${half + gap}" y="${half - thick/2}" width="${size}" height="${thick}" fill="${col}" fill-opacity="${alpha}" />`;
        svg += `<rect x="${half - thick/2}" y="${half - (gap+size)}" width="${thick}" height="${size}" fill="${col}" fill-opacity="${alpha}" />`;
        svg += `<rect x="${half - thick/2}" y="${half + gap}" width="${thick}" height="${size}" fill="${col}" fill-opacity="${alpha}" />`;
      } else if(s.crossStyle==='circle'){
        svg += `<circle cx="${half}" cy="${half}" r="${Math.max(6, size)}" fill="none" stroke="${col}" stroke-opacity="${alpha}" stroke-width="${Math.max(1, thick)}" />`;
      } else if(s.crossStyle==='t'){
        svg += `<rect x="${half - (gap+size)}" y="${half - thick/2}" width="${size}" height="${thick}" fill="${col}" fill-opacity="${alpha}" />`;
        svg += `<rect x="${half + gap}" y="${half - thick/2}" width="${size}" height="${thick}" fill="${col}" fill-opacity="${alpha}" />`;
        svg += `<rect x="${half - thick/2}" y="${half + gap}" width="${thick}" height="${size}" fill="${col}" fill-opacity="${alpha}" />`;
      }
      return `<svg width="64" height="64" viewBox="0 0 64 64">${svg}</svg>`;
    }
    function drawCrosshairOverlays(){
      document.getElementById('crosshair').innerHTML = crosshairSVG(Settings);
      document.getElementById('crossPreview').innerHTML = crosshairSVG(Settings);
    }

    // --------- Spawn helpers ---------
    function randomX(){ return THREE.MathUtils.randFloat(-ROOM_W/2+1.2, ROOM_W/2-1.2); }
    function randomY(){ return THREE.MathUtils.randFloat(1.2, ROOM_H-1.2); }
    function randomZ(){ return THREE.MathUtils.randFloat(-40, -20); } // -20..-40
    function chooseZ(){ return Settings.randZ ? randomZ() : Settings.fixedZ; }

    function noOverlap(pos, minDist){
      for(const o of targets.children){ if(pos.distanceTo(o.position) < minDist) return false; }
      return true;
    }

    function placeNonOverlapping(t){
      const minDist = Math.max(0.6, Settings.targetSize * Settings.minSeparation);
      let ok = false;
      for(let i=0;i<18;i++){
        t.position.set(randomX(), randomY(), chooseZ());
        if(noOverlap(t.position, minDist)){ ok = true; break; }
      }
      if(!ok){ t.position.set(randomX(), randomY(), chooseZ()); }
      targets.add(t);
    }

    function makeTarget(){
      const mesh = new THREE.Mesh(new THREE.SphereGeometry(Settings.targetSize, 24, 18), baseMat.clone());
      mesh.userData = {ttl: 2.0, vx:0, vy:0, vz:0, changeIn:0, baseColor:0x45b7ff, baseEm:0x0a3c66, onColor:0x29d391, onEm:0x1b6f4b, hover:false, yBase:null, zBase:null};
      return mesh;
    }
    function clearTargets(){ while(targets.children.length) targets.remove(targets.children[0]); State.currentTarget = null; }

    // --------- Shatter Type 1 ---------
    function spawnShatter(worldPos, colorHex=0x45b7ff){
      const N = 70;
      const geo = new THREE.BufferGeometry();
      const positions = new Float32Array(N*3);
      const velocities = new Float32Array(N*3);
      for(let i=0;i<N;i++){
        positions[i*3+0] = worldPos.x + (Math.random()*2-1)*0.05;
        positions[i*3+1] = worldPos.y + (Math.random()*2-1)*0.05;
        positions[i*3+2] = worldPos.z + (Math.random()*2-1)*0.05;
        const th = Math.random()*Math.PI*2;
        const ph = Math.acos(Math.random()*2-1);
        const sp = 2 + Math.random()*6;
        velocities[i*3+0] = Math.cos(th)*Math.sin(ph)*sp;
        velocities[i*3+1] = Math.cos(ph)*sp*0.6;
        velocities[i*3+2] = Math.sin(th)*Math.sin(ph)*sp;
      }
      geo.setAttribute('position', new THREE.BufferAttribute(positions,3));
      const mat = new THREE.PointsMaterial({color:colorHex, size:0.06, transparent:true, opacity:1, depthWrite:false});
      const pts = new THREE.Points(geo, mat);
      pts.userData = {velocities, life:0.6, maxLife:0.6};
      particleLayer.add(pts);
      particleClouds.push(pts);
    }
    function updateParticles(dt){
      for(let i=particleClouds.length-1;i>=0;i--){
        const p = particleClouds[i];
        p.userData.life -= dt;
        const t = p.userData;
        const pos = p.geometry.getAttribute('position');
        for(let j=0;j<pos.count;j++){
          pos.array[j*3+0] += t.velocities[j*3+0]*dt;
          pos.array[j*3+1] += (t.velocities[j*3+1]-2.5)*dt;
          pos.array[j*3+2] += t.velocities[j*3+2]*dt;
        }
        pos.needsUpdate = true;
        p.material.opacity = Math.max(0, t.life/t.maxLife);
        if(t.life<=0){
          particleLayer.remove(p);
          particleClouds.splice(i,1);
        }
      }
    }

    // --------- Modes ---------
    function setMode(m){
      Settings.mode = m; hud.mode.textContent = ({gridshot:'Gridshot', spidershot:'Spidershot', tracking:'Tracking'})[m];
      ui.endTrackingTimeRow.style.display = (m==='tracking') ? 'flex' : 'none';
    }

    function spawnGridshotTarget(){
      const t = makeTarget();
      t.userData.ttl = 6.0; // Gridshot 6s 自动消失
      placeNonOverlapping(t);
      return t;
    }

    function fillGridshotTargets(){
      while(targets.children.length < Settings.maxTargets){
        spawnGridshotTarget();
      }
    }

    function spawnSpidershot(){
      clearTargets();
      const t = makeTarget(); // ttl=2s
      t.position.set(randomX(), randomY(), chooseZ());
      t.userData.zBase = t.position.z;
      targets.add(t);
      State.currentTarget = t;
    }

    // Tracking movement
    function trackingChangeInterval(){
      const [a,b] = TrackChangeByDiff[Settings.difficulty] || [0.5,1.0];
      return THREE.MathUtils.randFloat(a,b);
    }
    function setTrackingVelocity(t){
      const s = Settings.targetSpeed;
      if(Settings.trackType==='parallel'){
        t.userData.vx = (Math.random()<0.5?-1:1) * THREE.MathUtils.randFloat(0.6*s, 1.2*s);
        t.userData.vy = 0; t.userData.vz = 0;
      }else{ // random on XY, fixed Z
        t.userData.vx = (Math.random()<0.5?-1:1) * THREE.MathUtils.randFloat(0.5*s, 1.1*s);
        t.userData.vy = (Math.random()<0.5?-1:1) * THREE.MathUtils.randFloat(0.5*s, 1.0*s);
        t.userData.vz = 0;
      }
      t.userData.changeIn = trackingChangeInterval();
    }
    function spawnTracking(){
      clearTargets();
      const t = makeTarget();
      t.material.color.setHex(0xff6b6b); t.material.emissive.setHex(0x5a1c1c);
      t.userData.baseColor = 0xff6b6b; t.userData.baseEm = 0x5a1c1c; t.userData.onColor = 0x7be495; t.userData.onEm = 0x1b6f4b;
      t.userData.yBase = randomY();
      t.userData.zBase = chooseZ();
      t.position.set(0, t.userData.yBase, t.userData.zBase);
      setTrackingVelocity(t);
      targets.add(t);
      State.currentTarget = t;
    }
    function animateTrackingTarget(t, dt){
      t.position.x += t.userData.vx * dt;
      t.position.y += t.userData.vy * dt;
      t.position.z = t.userData.zBase;
      if(t.position.x < -ROOM_W/2+1.2){ t.position.x = -ROOM_W/2+1.2; t.userData.vx *= -1; }
      if(t.position.x >  ROOM_W/2-1.2){ t.position.x =  ROOM_W/2-1.2; t.userData.vx *= -1; }
      if(Settings.trackType==='random'){
        const yMin = 1.2, yMax = ROOM_H-1.2;
        if(t.position.y < yMin){ t.position.y = yMin; t.userData.vy *= -1; }
        if(t.position.y > yMax){ t.position.y = yMax; t.userData.vy *= -1; }
      }else{
        t.position.y = t.userData.yBase;
      }
      t.userData.changeIn -= dt;
      if(t.userData.changeIn <= 0){ setTrackingVelocity(t); }
    }

    // --------- Floating score (+100) ---------
    const floatLayer = document.getElementById('floatLayer');
    function worldToScreen(pos){
      const p = pos.clone().project(camera);
      return { x:(p.x*0.5+0.5)*innerWidth, y:((-p.y*0.5)+0.5)*innerHeight, onScreen: (p.z>0 && p.x>-1 && p.x<1 && p.y>-1 && p.y<1) };
    }
    function spawnFloatText(worldPos, txt="+100"){
      if(Settings.mode==='tracking' || !Settings.floatScore) return;
      const screen = worldToScreen(worldPos);
      if(!screen.onScreen) return;
      const el = document.createElement('div');
      el.className = 'float';
      el.textContent = txt;
      const jitterX = (Math.random()*24-12), jitterY = (Math.random()*24-12);
      el.style.left = (screen.x + jitterX) + 'px';
      el.style.top  = (screen.y + jitterY) + 'px';
      floatLayer.appendChild(el);
      setTimeout(()=>{ el.remove(); }, 800);
    }

    // --------- Shooting & scoring ---------
    function onTargetHit(obj, autoRespawn){
      State.hits++; State.score += 100; State.streak++; if(State.streak>State.bestStreak) State.bestStreak = State.streak;
      spawnFloatText(obj.position, "+100");
      obj.material = hitMat.clone();
      targets.remove(obj);
      if(Settings.mode==='gridshot'){
        spawnGridshotTarget(); // 维持数量
      } else if(autoRespawn){
        spawnSpidershot();
      }
    }

    function shoot(){
      if(!State.running || State.phase!=='run' || Settings.mode==='tracking') return;
      State.shots++;
      raycaster.setFromCamera(center, camera);
      const hits = raycaster.intersectObjects(targets.children, false);
      if(hits.length){
        const o = hits[0].object;
        onTargetHit(o, Settings.mode==='spidershot');
        const col = (o.material?.color?.getHex?.()) || 0x29d391;
        spawnShatter(o.position, col);
        if(Settings.hitSound!=='off') playHit(Settings.hitSound, 0.05, 70);
      }else{
        State.streak = 0; playMiss();
      }
      updateHUD();
    }

    function updateTracking(dt){
      if(!State.currentTarget) return;
      animateTrackingTarget(State.currentTarget, dt);
      raycaster.setFromCamera(center, camera);
      const hits = raycaster.intersectObject(State.currentTarget, false);
      const on = hits.length>0;
      State.totalTrackingTime += dt;
      if(on){
        State.trackingOnTargetTime += dt;
        State.score += Math.max(1, Math.floor(50*dt));
        State.trkSfxTimer -= dt;
        if(State.trkSfxTimer<=0 && Settings.hitSound!=='off'){
          playHit(Settings.hitSound, 0.025, 40);
          State.trkSfxTimer = 0.04;
        }
        if(!State.currentTarget.userData.hover){
          State.currentTarget.material.color.setHex(State.currentTarget.userData.onColor);
          State.currentTarget.material.emissive.setHex(State.currentTarget.userData.onEm);
          State.currentTarget.userData.hover = true;
        }
      } else {
        State.trkSfxTimer = 0;
        if(State.currentTarget.userData.hover){
          State.currentTarget.material.color.setHex(State.currentTarget.userData.baseColor);
          State.currentTarget.material.emissive.setHex(State.currentTarget.userData.baseEm);
          State.currentTarget.userData.hover = false;
        }
      }
    }

    // --------- Micro info & HUD ---------
    function zLabel(){
      return Settings.randZ ? '随机(-20~-40)' : `固定(${Settings.fixedZ})`;
    }
    function updateMicroInfo(){
      if(!State.running){ micro.style.display='none'; return; }
      micro.style.display='block';
      const parts = [];
      if(Settings.mode==='gridshot') parts.push(`目标数量:${Settings.maxTargets}`);
      if(Settings.mode==='spidershot') parts.push(`路径:${Settings.showTrail?'显示':'隐藏'}`);
      parts.push(`难度:${Settings.difficulty}`);
      parts.push(`FOV:${Settings.fov}`);
      parts.push(`Z:${zLabel()}`);
      parts.push(`靶大小:${Settings.targetSize.toFixed(2)}`);
      parts.push(`速度:${Settings.targetSpeed.toFixed(1)}`);
      parts.push(`鼠标:${Math.round(State.mouseSpeed)}px/s`);
      micro.textContent = parts.join('｜');
    }

    function updateHUD(){
      hud.time.textContent = State.timeLeft.toFixed(1);
      hud.score.textContent = Math.floor(State.score);
      hud.hits.textContent = State.hits;
      hud.shots.textContent = State.shots;
      let acc = 0;
      if(Settings.mode==='tracking') acc = State.totalTrackingTime>0 ? (100*State.trackingOnTargetTime/State.totalTrackingTime) : 0;
      else acc = State.shots>0 ? (100*State.hits/State.shots) : 0;
      hud.acc.textContent = acc.toFixed(1)+"%";
      hud.mode.textContent = ({gridshot:'Gridshot', spidershot:'Spidershot', tracking:'Tracking'})[Settings.mode];
      updateMicroInfo();
    }
    function resetState(){
      State.timeLeft = Settings.duration;
      State.score = 0; State._scorePrev = 0;
      const buckets = Math.ceil(Settings.duration/5);
      State.scoreBuckets = new Array(buckets).fill(0);
      State.hits=0; State.shots=0; State.streak=0; State.bestStreak=0;
      State.trackingOnTargetTime = 0; State.totalTrackingTime = 0;
      State.lastTime = performance.now();
      State.trkSfxTimer = 0;
      State.mouseSpeed = 0;
      State.trailPts.length = 0;
      clearTargets();
      updateHUD();
    }

    // Ready phase (3s)
    function startReadyPhase(){
      State.phase = 'ready';
      State.readyLeft = 3.0;
      ui.readyLayer.style.display = 'flex';
      ui.readyNum.textContent = '3';
      micro.style.display='block';
      updateMicroInfo();
    }

    function startRunCore(){
      State.phase = 'run';
      State.timeLeft = Settings.duration;
      ui.readyLayer.style.display = 'none';
      if(Settings.mode==='gridshot'){
        clearTargets();
        fillGridshotTargets(); // 一开始就填满
      }
      if(Settings.mode==='spidershot') spawnSpidershot();
      if(Settings.mode==='tracking') spawnTracking();
      updateMicroInfo();
    }

    function startRun(){
      Settings.mode = State.pickedMode;
      Settings.maxTargets = State.pickedTargets;
      Settings.trackType = State.pickedTrackType;
      Settings.spiderTrail = State.pickedSpiderPath;
      Settings.showTrail = (Settings.spiderTrail === 'show');
      applySettings();
      resetState();
      setMode(Settings.mode);
      camera.fov = Settings.fov; camera.updateProjectionMatrix();

      State.running = true;
      hideMenu();
      canvas.requestPointerLock?.();
      State.pointerPos.x = innerWidth/2; State.pointerPos.y = innerHeight/2;
      startReadyPhase();
    }

    function drawEndChart(){
      const cvs = ui.endChart;
      const ctx = cvs.getContext('2d');
      const W = cvs.width, H = cvs.height;
      ctx.clearRect(0,0,W,H);
      const padL = 34, padR = 10, padT = 16, padB = 26;
      ctx.strokeStyle = '#1b2632'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(padL, padT); ctx.lineTo(padL, H-padB); ctx.lineTo(W-padR, H-padB); ctx.stroke();
      const data = State.scoreBuckets.slice();
      const maxV = Math.max(10, ...data);
      const n = data.length;
      ctx.fillStyle = '#7994ab'; ctx.font = '12px system-ui';
      for(let i=0;i<=5;i++){
        const y = padT + (H-padT-padB) * (i/5);
        ctx.strokeStyle = '#0f1a24'; ctx.beginPath(); ctx.moveTo(padL, y); ctx.lineTo(W-padR, y); ctx.stroke();
      }
      ctx.fillStyle = '#7fa6c3';
      for(let i=0;i<n;i++){
        const x = padL + (W-padL-padR) * (i/(n-1||1));
        if(i%2===0){ ctx.fillText(String(i*5), x-6, H-8); }
      }
      ctx.fillStyle = '#9db0c2';
      ctx.fillText('0', 8, H-padB+4);
      ctx.fillText(String(maxV), 6, padT+6);
      ctx.strokeStyle = '#29d391'; ctx.lineWidth = 2; ctx.lineJoin = 'round'; ctx.lineCap = 'round';
      ctx.beginPath();
      for(let i=0;i<n;i++){
        const x = padL + (W-padL-padR) * (i/(n-1||1));
        const y = padT + (H-padT-padB) * (1 - (data[i]/maxV));
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
      for(let i=0;i<n;i++){
        const x = padL + (W-padL-padR) * (i/(n-1||1));
        const y = padT + (H-padT-padB) * (1 - (data[i]/maxV));
        ctx.fillStyle = '#45b7ff';
        ctx.beginPath(); ctx.arc(x,y,2.6,0,Math.PI*2); ctx.fill();
      }
      ui.endBucketsLabel.textContent = `区间：0-${Settings.duration}s（每5s）`;
    }

    function endRun(){
      State.running = false;
      State.phase = 'menu';
      ui.endMode.textContent = ({gridshot:'Gridshot', spidershot:'Spidershot', tracking:'Tracking'})[Settings.mode];
      ui.endScore.textContent = Math.floor(State.score);

      const isTrack = Settings.mode==='tracking';
      ui.rowHM.style.display = isTrack ? 'none' : 'flex';
      ui.rowStreak.style.display = isTrack ? 'none' : 'flex';
      ui.endTrackingTimeRow.style.display = isTrack ? 'flex' : 'none';

      if(!isTrack){
        ui.endHM.textContent = `${State.hits} / ${State.shots}`;
      }
      let acc = 0;
      if(isTrack){
        acc = State.totalTrackingTime>0 ? (100*State.trackingOnTargetTime/State.totalTrackingTime) : 0;
        ui.endTrackTime.textContent = State.trackingOnTargetTime.toFixed(2)+" s";
      } else {
        acc = State.shots>0 ? (100*State.hits/State.shots) : 0;
        ui.endStreak.textContent = State.bestStreak;
      }
      ui.endAcc.textContent = acc.toFixed(1)+"%";
      ui.end.style.display = 'flex';
      micro.style.display='none';
      document.exitPointerLock?.();
      drawEndChart();
    }

    function abortToMenu(){
      State.running = false;
      State.phase = 'menu';
      clearTargets();
      micro.style.display='none';
      State.trailPts.length = 0;
      document.exitPointerLock?.();
      showMenu();
    }

    // --------- Trail rendering ---------
    function pushTrailPoint(x, y, force=false){
      if(!(Settings.mode==='spidershot' && Settings.showTrail && State.phase==='run' && State.running)) return;
      const now = performance.now();
      const pts = State.trailPts;
      const last = pts[pts.length-1];
      // 最小时间间隔与最小位移（避免堆积无意义点）
      const minDt = 16;          // ms ≈ 60fps
      const minDist2 = 0.5*0.5;  // px^2

      if(!force && last){
        const dx = x - last.x, dy = y - last.y;
        if((now - last.t) < minDt && (dx*dx + dy*dy) < minDist2) return;
      }
      pts.push({x, y, t: now});
    }

    function drawTrail(){
      const show = (Settings.mode==='spidershot' && Settings.showTrail && State.running);
      const w = innerWidth, h = innerHeight;
      tctx.clearRect(0,0,w,h);
      if(!show) return;

      const now = performance.now();
      const life = 2600; // ms
      const pts = State.trailPts;

      // 丢弃过期点
      let i = 0; 
      while(i < pts.length && now - pts[i].t > life) i++;
      if(i > 0) pts.splice(0, i);

      const cx = w/2, cy = h/2;
      if(pts.length === 0){
        // 仅画一个头部点（可选）
        tctx.fillStyle = 'rgba(69,183,255,0.85)';
        tctx.beginPath(); tctx.arc(cx, cy, 2.5, 0, Math.PI*2); tctx.fill();
        return;
      }

      // 计算把“最后一点”平移到屏幕中心的偏移量
      const last = pts[pts.length - 1];
      const tx = cx - last.x;
      const ty = cy - last.y;

      tctx.lineCap = 'round'; 
      tctx.lineJoin = 'round';

      for(let j=1; j<pts.length; j++){
        const p0 = pts[j-1], p1 = pts[j];
        const age = now - p1.t;
        const a = Math.max(0, 0.5 * (1 - age/life)); // 慢慢淡出
        if(a <= 0) continue;

        const speed = Math.hypot(p1.x - p0.x, p1.y - p0.y);
        const wline = Math.min(5, 1 + speed * 0.03);

        tctx.strokeStyle = `rgba(69,183,255,${a.toFixed(3)})`;
        tctx.lineWidth = wline;
        tctx.beginPath();
        tctx.moveTo(p0.x + tx, p0.y + ty);
        tctx.lineTo(p1.x + tx, p1.y + ty);
        tctx.stroke();
      }

      // 头部小点（固定在屏幕中心）
      tctx.fillStyle = 'rgba(69,183,255,0.85)';
      tctx.beginPath(); tctx.arc(cx, cy, 2.5, 0, Math.PI*2); tctx.fill();
    }


    // --------- Loop ---------
    function loop(){
      requestAnimationFrame(loop);
      const now = performance.now();
      const dt = Math.min(0.05, (now - State.lastTime)/1000);
      State.lastTime = now;

      if(State.running){
        if(State.phase==='ready'){
          State.readyLeft -= dt;
          const show = Math.ceil(State.readyLeft);
          ui.readyNum.textContent = Math.max(0, show).toString();
          if(State.readyLeft <= 0){
            startRunCore();
          }
        } else if(State.phase==='run'){
          State.timeLeft -= dt;
          const prevScore = State._scorePrev;

          if(Settings.mode==='tracking') updateTracking(dt);

          if(Settings.mode==='gridshot'){
            // 更新 TTL；到期移除并立刻补充
            for(let i=targets.children.length-1;i>=0;i--){
              const t = targets.children[i];
              t.userData.ttl -= dt;
              if(t.userData.ttl<=0){
                targets.remove(t);
                State.streak = 0;
                spawnGridshotTarget(); // 维持数量
              }
            }
            // 万一数量不足（极端情况），填满
            fillGridshotTargets();
          }

          if(Settings.mode==='spidershot' && State.currentTarget){
            State.currentTarget.userData.ttl -= dt;
            if(State.currentTarget.userData.ttl<=0){
              targets.remove(State.currentTarget);
              spawnSpidershot(); State.streak=0;
            }
          }

          // 统计每5秒的得分增量
          const elapsed = Settings.duration - State.timeLeft;
          const b = Math.min(State.scoreBuckets.length-1, Math.max(0, Math.floor(elapsed/5)));
          const inc = State.score - prevScore;
          if(inc>0) State.scoreBuckets[b] += inc;
          State._scorePrev = State.score;

          if(State.timeLeft <= 0){ State.timeLeft = 0; endRun(); }
        }
        updateHUD();
      }

      // particles update
      updateParticles(dt);
      if(Settings.mode==='spidershot' && Settings.showTrail && State.running && State.phase==='run'){
        pushTrailPoint(State.pointerPos.x, State.pointerPos.y, true);
      }
      drawTrail();
      // trail draw
      drawTrail();

      gunPivot.rotation.z = Math.sin(now*0.002)*0.02;
      gunPivot.rotation.x = Math.sin(now*0.0017)*0.01;
      camera.rotation.set(State.pitch, State.yaw, 0);
      renderer.render(scene, camera);
    }
    loop();

    // --------- Input & mouse speed ---------
    function onMouseMove(e){
      const now = performance.now();
      const dt = Math.max(1, now - State._lastMouseTime); // ms
      State._lastMouseTime = now;

      if(State.running && State.locked){
        const ax = Settings.accel, ay = Settings.accel;
        const dx = e.movementX || 0; const dy = e.movementY || 0;
        const scaleX = 0.002 * Settings.sensX * (1 + ax * Math.abs(dx));
        const scaleY = 0.002 * Settings.sensY * (1 + ay * Math.abs(dy));
        State.yaw   -= dx * scaleX;
        State.pitch -= dy * scaleY;
        const maxPitch = Math.PI/2 - 0.01;
        if(State.pitch >  maxPitch) State.pitch =  maxPitch;
        if(State.pitch < -maxPitch) State.pitch = -maxPitch;

        // mouse speed (px/s) smoothed
        const inst = Math.hypot(dx,dy) * 1000 / dt;
        State.mouseSpeed = State.mouseSpeed*0.85 + inst*0.15;

        // synth cursor for trail
        State.pointerPos.x = Math.max(0, Math.min(innerWidth, State.pointerPos.x + dx));
        State.pointerPos.y = Math.max(0, Math.min(innerHeight, State.pointerPos.y + dy));
        pushTrailPoint(State.pointerPos.x, State.pointerPos.y);
      }
    }
    function onPointerLockChange(){ 
      State.locked = (document.pointerLockElement === canvas);
      if(State.locked){
        State.pointerPos.x = innerWidth/2; 
        State.pointerPos.y = innerHeight/2; 
        State.trailPts.length = 0;
        State.trailPts.push({ x: innerWidth/2, y: innerHeight/2, t: performance.now() });
      }
    }
    addEventListener('mousemove', onMouseMove);
    document.addEventListener('pointerlockchange', onPointerLockChange);

    addEventListener('resize', ()=>{ 
      renderer.setSize(innerWidth, innerHeight); 
      camera.aspect = innerWidth/innerHeight; 
      camera.updateProjectionMatrix(); 
      sizeTrail();
    });
    addEventListener('contextmenu', e=>e.preventDefault());
    addEventListener('mousedown', (e)=>{ if(e.button===0) shoot(); });
    addEventListener('keydown', (e)=>{
      if(e.code==='KeyR' && menu.root.style.display==='none'){ startRun(); }
      if(e.code==='AltLeft' || e.code==='AltRight'){ abortToMenu(); }
    });

    // End screen buttons
    ui.closeEnd.onclick = ()=>{ ui.end.style.display='none'; showMenu(); };
    ui.endToMenu.onclick = ()=>{ ui.end.style.display='none'; showMenu(); };

    function showErr(msg){ ui.err.textContent = msg; ui.err.style.display = 'block'; console.error(msg); }

    // Init
    loadSettings();
    resetControlsFromSettings();
    applySettings();
    showMenu();
    drawCrosshairOverlays();
  </script>
</body>
</html>